\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage[a4paper,hmargin=0.8in,bottom=1.3in]{geometry}
\usepackage{lastpage,enumerate,fancyhdr,mathrsfs,graphicx,listings,hyperref,enumitem,listings}
\usepackage[dvipsnames]{xcolor}
\newcommand{\citem}[1]{\item \texttt{#1}}
\author{Hardik Rajpal}
\title{Notes from nearly draining pursuits of mastery in Leetcode problems}
\hbadness 100001
\begin{document}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\maketitle
\tableofcontents
\pagebreak
\section{STL}
\subsection{Sets and Maps}
These (\texttt{set} and \texttt{map}) are ordered data structures; helpful when
it is efficient to retain the ordering of a collection of elements during execution.
Their unordered counterparts (\texttt{unordered\_set} and \texttt{unorderd\_map})
prioritize access time and maintain no order of their elements.
\subsubsection*{Declaration syntaxes}
\begin{lstlisting}[caption={Sets and Maps},language=C++]
struct U{
    bool operator()(T t1, T t2)const{
        //logic comparing t1<t2.
    }
};
set<T,struct U> myset; multiset<T,struct U> mymulset;
map<T,V,struct U> mymap; multimap<T,struct U> mymulmap;
\end{lstlisting}
The ordering parameter \texttt{U} is crucial in cases where order between T is not inferable.
\begin{lstlisting}[caption={Unordered sets and maps}]
struct T{
    ...
    bool operator==(T t2)const{
        //return logic for t2==this.
    }
};
struct hashT{
    size_t operator()(T t)const{
        //std::hash<string or int or double>()(string or int or double)
        //return logic for hashing t. Use ^ << >> ~ | &
    }
};
unordered_set<T,struct hashT> uset;
unordered_map<T,V,struct hashT> umap;
\end{lstlisting}
\subsection{Iterators}
An iterator pointing at an element is ``corrupted" on removing the element.
Hence, any useful data should be copied over the iterator before removing the element.
\begin{lstlisting}[caption={Undefined behaviour},language=C++]
    lists.erase(*minit);//minit is corrupted
    lists.insert((*minit)->next);
\end{lstlisting}
\begin{lstlisting}[caption={Working code}]
    lists.insert((*minit)->next);//first use the data.
    lists.erase(*minit);//then erase.
\end{lstlisting}
\subsection{Built-In Utilities}
Note: \texttt{iter} denotes the iterator return type. \texttt{first} and \texttt{last} denote \texttt{.begin()} and \texttt{.end()} iterators.
\begin{itemize}
    \citem{void sort(first,last)} (O(nlogn))
    \citem{void reverse(first,last)} (O(n))
    \citem{void random\_shuffle(first,last)} (O(n))
    \citem{iter max\_element(first,last[,struct comp])} (O(n))
    \citem{iter min\_element(first,last[,struct comp])} (O(n))
    \citem{int | long long | etc accumulate(first,last,init\_val)} (O(n))
    \citem{iter lower\_bound(first,last,value)}(O(logn))
    \begin{itemize}
        \item Returns \texttt{iter} to the smallest element $\geq$ \texttt{value}.
    \end{itemize}
    \citem{iter upper\_bound(first,last,value)} (O(logn))
    \begin{itemize}
        \item Returns \texttt{iter} to the smallest element $>$ \texttt{value}.
    \end{itemize}
    \citem{bool next\_permutation(first,last[, struct comp])} (O(n))
    \begin{itemize}
        \item Updates \texttt{(first,last)} to its next permutation of in ascending order.
        \item Sort \texttt{(first,last)} first to access all permutations.
        \item Use in a \texttt{do-while} loop to avoid missing first permutation.
        \item Returns true if there exists a permutation greater than the current one.
    \end{itemize}
    \citem{bool prev\_permutation(first, last[, struct comp])} (O(n))
\end{itemize}
\section{Graph Algorithms}
\subsection{BFS|DFS}
I prefer writing both of these iteratively. In the immortal
intonation of Ashish Mishra,\\
\textbf{BFS} - \textbf{Queue}\\
\textbf{DFS} - \textbf{Stack}\\
Here's a sample of both algorithms.\\
\noindent\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[caption=BFS]
T s;
unordered_map<T,vector<T>> edges;
queue<T> q;
unordered_map<T,bool> visited;
unordered_map<T,T> prev;
int steps = 0;
q.push(s);
visited[s] = true;
while(!q.empty()){
    int sz = q.size();
    while(sz--){
        T u = q.front();
        q.pop();
        for(nb:edges[u]){
            if(!visited[nb]){
               visited[nb] = true;
               prev[nb] = u;
               q.push(nb);
            }
        }
    }
    steps++;
}
        \end{lstlisting}
    \end{minipage}\hfill
    \begin{minipage}{.45\textwidth}
        \begin{lstlisting}[caption=DFS]
T s;
unordered_map<T,vector<T>> edges;
stack<T> s;
unordered_map<T,bool> visited;
unordered_map<T,T> prev;
s.push(s);
visited[s] = true;
while(!s.empty()){
    T u = s.top();
    s.pop();
    for(nb:edges[u]){
        if(!visited[nb]){
            visited[nb] = true;
            prev[nb] = u;
            q.push(nb);
        }
    }
}
\end{lstlisting}
\end{minipage}\\
The nodes should be reduced from the abstract type T, to
int whenever possible; thereby reducing the
\texttt{unordered\_map}s to \texttt{vector}s which can
sometimes get you under the time limit.
\href{https://stackoverflow.com/questions/55451825/why-is-vector-faster-than-unordered-map}{Click here for Why?}
\subsubsection*{Optimizations}
\begin{itemize}
    \item If the list of neighbours is a shared data structure, consider clearing it after having visited
    the neighbours using any one owner. Since, all elements in the shared field are visited and running them
    through the loop for other owners of the field is redundant. \href{https://leetcode.com/problems/jump-game-iv/}{(Leetcode)}
\end{itemize}
\section{Misc. Algorithms}
\subsection{Binary Search}
While the idea of binary search is clear, opportunities
for its application may not be easily identified (yet). Some
common places where it may be applied:
\subsubsection*{Optimization Problems}
Problems involving the evaluation of the min/max of an expression,
while its constituents satisfy a constraint that is straightforward to
check. Consider the problem below:\\
\begin{center}
\fbox{Given $x_1,x_2,...x_n$ and $T$, find $min_{a_1,a_2,...a_n}(max_i(a_ix_i))$ such that $\sum_{i=0}^{n}{a_i}\geq T$ \href[]{https://leetcode.com/problems/minimum-time-to-complete-trips/description/}{(Leetcode)}}
\end{center}
The binary search algorithm is:
\begin{lstlisting}[language=C++,caption=BinSearch]
    int n = x.size();
    int mine = *min_element(x.begin(),x.end());
    int maxe = *max_element(x.begin(),x.end());
    unsigned long long lb = mine, ub = T*(unsigned long long)maxe;
    unsigned long long del = (ub - lb)/2;
    auto numtrips = [x,n](unsigned long long gt){
        unsigned long long nt = 0;
            for(int i=0;i<n;i++){
                nt += (gt/x[i]);
            }
            return nt;
    };
    while(del>0){
        if(numtrips(lb+del)>=T){
            ub = lb + del;
        }
        else{
            lb = lb + del;
        }
        del = (ub-lb)/2;
    }
    if(numtrips(lb)>=T){
        return lb;
    }
    return lb+1;
\end{lstlisting}
\subsection{Array Scan}
The name is given to the family of algorithms where we do a couple of runs of a given array to evaluate an attribute. Approaches involving subarrays can be dealt with using to two indices \texttt{s} and \texttt{e}. Things to note:
\begin{itemize}
    \item Edge cases are possible at the start or end.
    \item The attribute evaluation will often be have to be done once more at the end of the loop.
    \item To improve performance, try to reduce the variables being updated/used in the loop.
    \item Two loops are useful for getting started with the code, but reducing them to one helps performance.
\end{itemize}
\end{document}