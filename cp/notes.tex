\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage[a4paper,hmargin=0.8in,bottom=1.3in]{geometry}
\usepackage{lastpage,enumerate,fancyhdr,mathrsfs,xcolor,graphicx,listings,hyperref,enumitem,listings}
\author{Hardik Rajpal}
\title{Notes from nearly draining pursuits of mastery in Leetcode problems}
\begin{document}
\maketitle
\tableofcontents
\pagebreak
\section{Graph Algorithms}
\subsection{BFS|DFS}
I prefer writing both of these iteratively. In the immortal
intonation of Ashish Mishra,\\
\textbf{BFS} - \textbf{Queue}\\
\textbf{DFS} - \textbf{Stack}\\
Here's a sample of both algorithms.\\
\noindent\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[caption=BFS]
T s;
unordered_map<T,vector<T>> edges;
queue<T> q;
unordered_map<T,bool> visited;
unordered_map<T,T> prev;
int steps = 0;
q.push(s);
visited[s] = true;
while(!q.empty()){
    int sz = q.size();
    while(sz--){
        T u = q.front();
        q.pop();
        for(nb:edges[u]){
            if(!visited[nb]){
                visited[nb] = true;
                prev[nb] = u;
                q.push(nb);
            }
        }
    }
    steps++;
}
        \end{lstlisting}
    \end{minipage}\hfill
    \begin{minipage}{.45\textwidth}
        \begin{lstlisting}[caption=DFS]
T s;
unordered_map<T,vector<T>> edges;
stack<T> s;
unordered_map<T,bool> visited;
unordered_map<T,T> prev;
s.push(s);
visited[s] = true;
while(!s.empty()){
    T u = s.top();
    s.pop();
    for(nb:edges[u]){
        if(!visited[nb]){
            visited[nb] = true;
            prev[nb] = u;
            q.push(nb);
        }
    }
}
    \end{lstlisting}
    \end{minipage}
    
\end{document}